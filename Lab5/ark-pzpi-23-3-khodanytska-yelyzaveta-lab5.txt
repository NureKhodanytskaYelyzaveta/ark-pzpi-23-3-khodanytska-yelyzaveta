Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії

Звіт
з лабораторної роботи № 5
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Програмна система для автоматизації роботи бібліотек»


Виконала:                                                                Перевірив:
ст. гр. ПЗПІ-23-3						ст. викладач катедри ПІ
Ходаницька Єлизавета 					Сокорчук Ігор Петрович







Харків - 2025
1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
17.12.2025
0.1
Початок роботи над презентацією і доповіддю
2
19.12.2025
0.2
Редагування попередньої версії


2 ЗАВДАННЯ 
Навчитися розгортати програмну систему, перевіряти її функціональність, виконувати налаштування, а також демонструвати та документувати роботу системи.

3 ОПИС ВИКОНАНОЇ РОБОТИ
	3.1 Розгортання програмної системи та конфігурація середовища
У рамках виконання лабораторної роботи було здійснено розгортання програмної системи для автоматизації роботи бібліотеки з використанням сучасних інструментів контейнеризації та серверних технологій. Основною метою даного етапу було створення стабільного, відтворюваного та незалежного від конкретного середовища виконання рішення, яке дозволяє коректно продемонструвати роботу всіх компонентів системи (див. рис. Б.1).
Серверна частина системи розгортається у вигляді Docker-контейнера, який містить усі необхідні залежності для запуску Flask-додатку, зокрема бібліотеки для обробки HTTP-запитів, роботи з REST API та взаємодії з базою даних. Використання Docker дозволяє ізолювати серверну логіку від операційної системи хоста, що значно спрощує розгортання, тестування та подальше масштабування системи.
Під час запуску контейнера здійснюється проброс мережевого порту, що забезпечує доступ до серверу ззовні. Серверна частина працює в режимі постійного очікування запитів і приймає HTTP-запити від клієнтських компонентів системи, зокрема веб-клієнта та IoT-клієнта. Обмін даними здійснюється у форматі JSON, що є стандартним для REST-орієнтованих систем.
Для зберігання даних використовується вбудована база даних SQLite, яка взаємодіє із сервером через ORM SQLAlchemy. Таке рішення є доцільним на етапі розробки та демонстрації, оскільки не потребує розгортання окремого серверу бази даних, але водночас зберігає можливість подальшої міграції на повноцінну СУБД, PostgreSQL, без змін у бізнес-логіці.
IoT-клієнт реалізований як окремий програмний модуль та запускається незалежно від Docker-контейнера. Він взаємодіє із серверною частиною через мережу, використовуючи адресу серверу, зазначену в конфігураційному файлі. Такий підхід дозволяє емулювати реальну взаємодію фізичного пристрою з сервером у розподіленій системі.
	3.2 Обґрунтування вибору технологій
Вибір технологій для реалізації та розгортання системи був зумовлений вимогами до гнучкості, простоти інтеграції та можливості подальшого розвитку проєкту. Як серверний фреймворк було обрано Flask, оскільки він забезпечує мінімалістичний підхід до побудови веб-додатків та добре підходить для створення RESTful-сервісів.
Flask дозволяє чітко структурувати код серверної частини, розділивши його на контролери, сервісний рівень та рівень доступу до даних. Така архітектура сприяє кращій підтримуваності коду та полегшує внесення змін у бізнес-логіку системи.

Для роботи з базою даних використовується SQLAlchemy ORM, що забезпечує абстракцію від конкретної реалізації СУБД. На поточному етапі обрано SQLite як легку та зручну базу даних, однак використання ORM дозволяє безболісно перейти на більш продуктивні рішення, такі як PostgreSQL, у разі зростання навантаження.
Контейнеризація за допомогою Docker була використана з метою стандартизації середовища виконання. Це дозволяє гарантувати, що серверна частина працює однаково незалежно від платформи, на якій здійснюється запуск, а також спрощує демонстрацію системи.
Для обміну даними між компонентами було обрано протокол HTTP/HTTPS та REST API. Такий підхід є універсальним, добре задокументованим і підтримується більшістю мов програмування, що особливо важливо для інтеграції IoT-клієнта з серверною частиною.
	3.3 Логіка бізнес-процесів серверної частини
Бізнес-логіка серверної частини є центральним елементом програмної системи та визначає правила обробки всіх основних операцій, пов’язаних із функціонуванням бібліотеки. Саме на сервері зосереджено всі рішення, що впливають на стан даних, що дозволяє забезпечити їхню цілісність та узгодженість (див. рис. Б.2). 
Система підтримує повний цикл взаємодії користувачів із бібліотечним фондом — від пошуку книг у каталозі до їх повернення. Процес починається з пошуку, під час якого сервер обробляє запит користувача та виконує відповідну вибірку з бази даних за назвою, автором або теґами.
Після знаходження необхідної книги читач може створити бронювання. Серверна логіка перевіряє доступність книги, формує запис резервування та автоматично змінює її статус. Подальша видача книги здійснюється бібліотекарем, після чого система створює запис позики, встановлює дату повернення та змінює статус книги на відповідний.
Повернення книги супроводжується перевіркою наявності активної позики та оновленням даних у базі. У разі прострочення система здатна виявити це та відобразити відповідну інформацію для бібліотекаря або адміністратора.
Завдяки чітко визначеній бізнес-логіці та системі статусів кожна книга в будь-який момент перебуває в одному коректному стані, що виключає суперечливі ситуації та помилки в обліку.
	3.4 Логіка адміністрування серверної частини
Адміністративна складова серверної частини програмної системи забезпечує управління користувачами, даними та загальними параметрами роботи бібліотеки. Адміністратор виконує роль центрального керівного елементу, відповідального за стабільність та ефективність функціонування системи.
Функціонал адміністрування включає керування обліковими записами користувачів, зокрема створення нових акаунтів, редагування наявних та зміну ролей. Такий підхід дозволяє гнучко розмежовувати доступ до функцій системи відповідно до ролі користувача.
Окрім цього адміністратор має доступ до аналітичного функціоналу, який дозволяє отримувати узагальнену інформацію про роботу бібліотеки. Зокрема система надає дані щодо популярності книг, активності читачів, кількості позик і повернень, а також наявності прострочених замовлень.
Аналітичні запити виконуються на сервері, що дозволяє зменшити навантаження на клієнтські пристрої та забезпечити єдину точку обробки даних. Отримана інформація може бути використана для прийняття управлінських рішень та планування подальшого розвитку бібліотеки.

	3.5 Логіка налаштування IoT-клієнта та взаємодії з сервером
IoT-клієнт у даній системі реалізований як допоміжний компонент, який забезпечує безконтактну видачу та повернення книг через автоматизовані комірки. Його основним завданням є взаємодія з користувачем та передача відповідних запитів на серверну частину.
Клієнт не містить бізнес-логіки та не приймає рішень щодо стану книг або можливості виконання операцій. Усі критично важливі перевірки та зміни виконуються виключно на сервері. Такий підхід дозволяє уникнути дублювання логіки та зберегти цілісність даних.
Взаємодія між IoT-клієнтом і сервером здійснюється через REST API з використанням протоколу HTTP/HTTPS. Для цього серверна частина була доповнена спеціалізованими ендпоінтами, які відповідають за генерацію та валідацію OTP, відкриття комірок і підтвердження операцій видачі та повернення.
Налаштування IoT-клієнта виконується через зовнішній конфігураційний файл, у якому зберігаються параметри з’єднання з сервером, кількість комірок і часові обмеження. Такий підхід забезпечує гнучкість налаштувань та спрощує адаптацію клієнта до різних умов експлуатації.
У підсумку розроблений IoT-клієнт органічно доповнює серверну частину системи, розширюючи її функціональні можливості та забезпечуючи сучасний рівень автоматизації бібліотечних процесів.

4 ВИСНОВКИ
У ході виконання лабораторної роботи було опановано процес розгортання програмної системи, перевірки її функціональності та виконання необхідних налаштувань, а також було розгорнуто серверну частину системи, налаштовано взаємодію з базою даних і клієнтськими компонентами, а також перевірено коректність роботи основних бізнес-процесів і REST API.

5 ВИКОРИСТАНІ ДЖЕРЕЛА 
What is docker?. Docker Documentation. URL: https://docs.docker.com/get-started/docker-overview/ (date of access: 18.12.2025).
A docker tutorial for beginners. A Docker Tutorial for Beginners. URL: https://docker-curriculum.com/ (date of access: 18.12.2025).
Os. IBM. URL: https://www.ibm.com/docs/en/zos/3.1.0?topic=task-deploying-software (date of access: 18.12.2025).

ДОДАТОК А 
Відеозапис 
Відеозапис доповіді: https://youtu.be/BkpBY-1dJ0c
Хронологічний опис відеозапису:
0:00 - Вступ
0:18 - Розгортання програмної системи та конфігурація середовища
1:48 - Обґрунтування вибору технологій
2:30 - Логіка бізнес-процесів серверної частини
3:15 - Логіка адміністрування серверної частини
3:39 - Логіка налаштування IoT-клієнта та взаємодії з сервером
4:05 - Висновки
4:25 - Демонстрація


ДОДАТОК Б
Діаграми

Рисунок Б.1 — Схема взаємодії компонентів програмної системи.

Рисунок Б.2 — Діаграма структури даних


ДОДАТОК В
Програмний код 
В.1 Програмний код для розгортання
 1 # Dockerfile
 2 FROM python:3.11-slim
 3
 4 WORKDIR /app
 5
 6 COPY requirements.txt .
 7 RUN pip install --no-cache-dir -r requirements.txt
 8
 9 COPY . .
10
11 # Відкриває порт 5000
12 EXPOSE 5000
13
14 # Запускає сервер
15 CMD ["python", "main.py"]

В.2 Фрагмент логіки IoT
 1 @app.route("/iot/lockers/unlock", methods=["POST"])
 2 def unlock_locker():
 3     data = request.get_json()
 4     otp = data.get("otp")
 5
 6     locker = validate_otp(otp)
 7     if not locker:
 8         return jsonify({"error": "Invalid OTP"}), 400
 9
10     return jsonify({
11         "locker_id": locker.id,
12         "book_id": locker.book_id,
13         "user_id": locker.user_id
14     })

В.3 Фрагмент логіки адміністрування
 1 def create_user(db, name, email, password, role):
 2     user = User(
 3         name=name,
 4         email=email,
 5         password_hash=hash_password(password),
 6         role=role
 7     )
 8     db.add(user)
 9     db.commit()
10     return user

В.4 Фрагмент взаємодії IoT-клієнта з сервером
 1 response = requests.post(
 2     f"{SERVER_URL}/iot/lockers/unlock",
 3     json={"otp": otp},
 4     timeout=5
 5 )
 6
 7 if response.status_code == 200:
 8     open_locker(response.json()["locker_id"])

В.5 Конфігураційний файл IoT-клієнта
 1 {
 2   "server_url": "http://localhost:5000",
 3   "network_timeout": 5,
 4   "max_lockers": 5
 5 }
